extern crate serde;

use pnet_macros_support::types::*;

use std::fmt;
use std::net::Ipv4Addr;
use std::ops::Add;

use self::serde::ser::Serialize;
use self::serde::ser::SerializeStruct;
use self::serde::Serializer;
use time::{Duration, Tm};

#[packet]
pub struct Netflow {
    version: u16be,
    count: u16be,
    sys_uptime: u32be,
    unix_secs: u32be,
    unix_nsecs: u32be,
    flow_sequence: u32be,
    engine_type: u8,
    engine_id: u8,
    sampling_interval: u16be,
    #[length_fn = "netflow_records_length"]
    records: Vec<Record>,

    #[payload]
    payload: Vec<u8>
}

fn netflow_records_length(p: &NetflowPacket) -> usize {
    p.get_count() as usize * 48
}

#[packet]
pub struct Record {
    #[construct_with(u8, u8, u8, u8)]
    source: Ipv4Addr,
    #[construct_with(u8, u8, u8, u8)]
    destination: Ipv4Addr,
    #[construct_with(u8, u8, u8, u8)]
    next_hop: Ipv4Addr,
    input: u16be,
    output: u16be,
    d_pkts: u32be,
    d_octets: u32be,
    first: u32be,
    last: u32be,
    src_port: u16be,
    dst_port: u16be,
    // is there a better way to handle padding?
    pad1: u8,
    tcp_flags: u8,
    prot: u8,
    tos: u8,
    src_as: u16be,
    dst_as: u16be,
    src_mask: u8,
    dst_mask: u8,
    pad2: u16be,
    // is there a better way to do this?
    #[payload]
    #[length_fn = "record_payload_length"]
    payload: Vec<u8>
}

fn record_payload_length(p: &RecordPacket) -> usize {
    0usize
}

impl Record {
    pub fn source(&self) -> &Ipv4Addr {
        &self.source
    }

    pub fn destination(&self) -> &Ipv4Addr {
        &self.source
    }

    pub fn next_hop(&self) -> &Ipv4Addr {
        &self.next_hop
    }

    pub fn input(&self) -> u16 {
        self.input
    }

    pub fn output(&self) -> u16 {
        self.output
    }

    pub fn d_pkts(&self) -> u32 {
        self.d_pkts
    }

    pub fn d_octets(&self) -> u32 {
        self.d_octets
    }

    pub fn first_sec(&self, boot: Tm) -> i64 {
        let f = boot.add(
            Duration::milliseconds(self.first as i64)
        ).to_timespec();
        f.sec
    }

    pub fn first_nsec(&self, boot: Tm) -> i32 {
        let f = boot.add(
            Duration::milliseconds(self.first as i64)
        ).to_timespec();
        f.nsec
    }

    pub fn last_sec(&self, boot: Tm) -> i64 {
        let f = boot.add(
            Duration::milliseconds(self.last as i64)
        ).to_timespec();
        f.sec
    }

    pub fn last_nsec(&self, boot: Tm) -> i32 {
        let f = boot.add(
            Duration::milliseconds(self.last as i64)
        ).to_timespec();
        f.nsec
    }

    pub fn last_timestamp(&self, boot: Tm) -> Tm {
        boot.add(Duration::milliseconds(self.last as i64))
    }

    pub fn src_port(&self) -> u16 {
        self.src_port
    }

    pub fn dst_port(&self) -> u16 {
        self.dst_port
    }

    pub fn tcp_flags(&self) -> u8 {
        self.tcp_flags
    }

    pub fn prot(&self) -> u8 {
        self.prot
    }

    pub fn tos(&self) -> u8 {
        self.tos
    }

    pub fn src_as(&self) -> u16 {
        self.src_as
    }

    pub fn dst_as(&self) -> u16 {
        self.dst_as
    }

    pub fn src_mask(&self) -> u8 {
        self.src_mask
    }

    pub fn dst_mask(&self) -> u8 {
        self.dst_mask
    }
}

impl Serialize for Record {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where S: Serializer
    {
        let mut struc = serializer.serialize_struct("Record", 16)?;
        struc.serialize_field("source", self.source())?;
        struc.serialize_field("destination", self.destination())?;
        struc.serialize_field("next_hop", self.next_hop())?;
        struc.serialize_field("input", &self.input())?;
        struc.serialize_field("output", &self.output())?;
        struc.serialize_field("d_pkts", &self.d_pkts())?;
        struc.serialize_field("d_octets", &self.d_octets())?;
        // TODO resolved time
        // struc.serialize_field("first_sec", &self.first_sec(boot));
        // struc.serialize_field("first_nsec", &self.first_nsec(boot));
        // struc.serialize_field("last_sec", &self.last_sec(boot));
        // struc.serialize_field("last_nsec", &self.last_nsec(boot));
        struc.serialize_field("src_port", &self.src_port())?;
        struc.serialize_field("dst_port", &self.dst_port())?;
        struc.serialize_field("tcp_flags", &self.tcp_flags())?;
        struc.serialize_field("prot", &self.prot())?;
        struc.serialize_field("tos", &self.tos())?;
        struc.serialize_field("src_as", &self.src_as())?;
        struc.serialize_field("dst_as", &self.dst_as())?;
        struc.serialize_field("src_mask", &self.src_mask())?;
        struc.serialize_field("dst_mask", &self.dst_mask())?;
        struc.end()
    }
}

impl fmt::Display for Record {
    // This trait requires `fmt` with this exact signature.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Write strictly the first element into the supplied output
        // stream: `f`. Returns `fmt::Result` which indicates whether the
        // operation succeeded or failed. Note that `write!` uses syntax which
        // is very similar to `println!`.
        write!(f, "{src:>width$} -> {dst:>width$}", src=self.source, dst=self.destination, width=15)
    }
}

#[test]
fn netflow_packet_test() {
    let mut packet = [0u8; 24];
    {
        let mut netflow = MutableNetflowPacket::new(&mut packet[..]).unwrap();
        netflow.set_version(5);
        assert_eq!(netflow.get_version(), 5);

        netflow.set_count(1);
        assert_eq!(netflow.get_count(), 1);

        netflow.set_sys_uptime(1228600932);
        assert_eq!(netflow.get_sys_uptime(), 1228600932);

        netflow.set_unix_secs(1185457716);
        assert_eq!(netflow.get_unix_secs(), 1185457716);

        netflow.set_unix_nsecs(855073578);
        assert_eq!(netflow.get_unix_nsecs(), 855073578);

        netflow.set_flow_sequence(2922592624);
        assert_eq!(netflow.get_flow_sequence(), 2922592624);

        netflow.set_engine_type(0);
        assert_eq!(netflow.get_engine_type(), 0);

        netflow.set_engine_id(5);
        assert_eq!(netflow.get_engine_id(), 5);

        netflow.set_sampling_interval(0);
        assert_eq!(netflow.get_sampling_interval(), 0);

    }
}
